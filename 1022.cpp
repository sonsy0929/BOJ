/*
시간복잡도 : O(2 * (r1 - r2) + 2 * (c2 - c1))

만약 전처리 작업으로 미리 배열에 좌표에 해당하는 값을 넣으면,
|N| <= 5000은 -5000 <= N <= 5000이므로 최대 N의 크기는 10000이 된다.
[10000][10000] 배열 선언은 1e8 * 4byte이므로 약 380MB가 된다.
메모리 제한에도 걸리고 시간 제한에도 걸리게 되므로 naive하게 구현을 하면 안된다.
가운데 있는 1을 기준으로, 잘 관찰을 해보면 4방향의 대각선이 일정한 규칙을 보인다.

오른쪽 위의 대각선 같은 경우
1 -> 3 -> 13 -> 31... 이런 수열을 확인할 수 있다.
각각의 차이를 구해보면 2, 10, 18...와 같은 수열이 나타나고,
이는 등차가 8로 증가하는 계차수열임을 확인할 수 있다.
즉, 일반항으로 표현이 가능하다. => 4N^2 - 2N + 1

왼쪽 아래의 대각선 같은 경우
1 -> 7 -> 21 -> 43... 이런 수열을 확인할 수 있다.
각각의 차이를 구해보면, 6, 14, 22...와 같은 수열이 나타나고,
이 또한 등차가 8로 증가하는 계차수열임을 확인할 수 있다.
즉, 일반항으로 표현이 가능하다. => 4N^2 + 2N + 1

이를 통해, 좌표가 주어지면 O(1)만에 그 좌표에 해당하는 값이 무엇인지 알 수 있다.
현재 좌표에서 절대값의 최대값을 구하면, 몇 번째 사각형인지 알 수 있다.
이를 통해 해당 좌표가 사각형의 어느 변에 해당하는지 확인을 하고,
RU(우측상단) 혹은 LD(좌측하단)의 값을 통해 해당 좌표와의 거리를 더해주거나 빼주면
원하는 값을 O(1)만에 얻을 수 있다.
*/

#include <bits/stdc++.h>
using namespace std;
int r1, c1, r2, c2;
int get(int r, int c) {
    int N = max(abs(r), abs(c));
    int RU = 4 * N * N - 2 * N + 1;
    int LD = 4 * N * N + 2 * N + 1;
    if (r == -N) return RU + (N - c);
    if (r == N) return LD + (c + N);
    if (c == -N) return LD - (N - r);
    if (c == N) return RU - (r + N);
}
int main() {
    scanf("%d %d %d %d", &r1, &c1, &r2, &c2);
    int mx = 0;
    for (int i = r1; i <= r2; i++) {
        for (int j = c1; j <= c2; j++) {
            int sz = to_string(get(i, j)).size();
            mx = max(mx, sz);
        }
    }
    for (int i = r1; i <= r2; i++) {
        for (int j = c1; j <= c2; j++) {
            printf("%*d ", mx, get(i, j));
        }
        puts("");
    }
}